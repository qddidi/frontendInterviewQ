## 原型与原型链

在 JavaScript 中，原型和原型链是一个很重要的知识点，只有理解了它，我们才能更深刻的理解 JavaScript

在理解原型与原型链之前,我们先看一下什么是构造函数:其实构造函数和普通函数没啥区别,只不过使用了 new 关键字创建对象的函数，被叫做了构造函数

- 原型
  每个构造函数都有一个原型对象(prototype),原型对象有一个 constructor 函数,比如

```js
function MyFun() {}

MyFun.prototype; //{constructor: ƒ,__proto__:...}
```

其中 constructor 就是构造函数本身,当我们实例化这个函数时候,这个实例化后的对像有一个`__proto__`属性,而这个属性则指向构造函数的原型对象(MyFun.prototype),所以每一个实例化的对象的`__proto__`都会指向构造函数的原型对象,因此可以在构造函数的原型对象写一些公共的方法

```js
function MyFun() {}
MyFun.prototype.sayHello = function () {
  console.log("hello");
};
const a = new MyFun(); //{__proto__:xxx}, 注意在chrome浏览器显示为[[Prototype]]

a.sayHello(); //hello
```

我们可以发现可以直接调用`a.sayHello`而不用这样写`a.__proto__.sayHello`,这就是接下来要介绍的原型链了

- 原型链

当我们获取一个对象的属性时,首先会查找这个对象本身有没有这个属性,如果没有则会去它的原型中查找(`.__proto__`)也就是构造函数的 prototype,如果还是查不到,由于构造函数的 prototype 也是个对象,所以它也有`.__proto__`,因此会继续查找构造函数的 prototype 的`__proto__`,如果还是没有怎会继续往下查找,直到查询到`Object.prototype.__proto__`(返回 null)为止

可以看出，整个查找过程都是顺着`__proto__`属性，一步一步往上查找，形成了像链条一样的结构，这个结构，就是原型链。

## intanceof 操作符的实现原理及实现

intanceof 可以用于判断一个对象的原型`__proto__`是否在一个构造函数的原型链上,比如

```js
function MyFun() {}

const a = new MyFun();

a instanceof MyFun; //true
```

**原理**

> 首先会判断 a 的原型是否等于构造函数的原型(myFun.prototype),a 的原型可以使用`a.__proto__`获取,但这并不标准的获取原型方法,因此我们可以使用`Object.getPrototypeOf(a)`获取 a 的原型,如果我 a 的原型不等于构造函数的原型(myFun.prototype),再判断 a 的原型的原型`Object.getPrototypeOf(Object.getPrototypeOf(a))`是否等于构造函数的原型(myFun.prototype),以此类推,直到获取到了原型为 null 则返回 false

知道了原理,实现起来就很简单了

```js
//left intanceof right
function myInstanceof(left, right) {
  // 获取对象的原型
  let proto = Object.getPrototypeOf(left);
  // 获取构造函数的 prototype 对象
  let prototype = right.prototype;

  // 判断构造函数的 prototype 对象是否在对象的原型链上
  while (true) {
    if (!proto) return false;
    if (proto === prototype) return true;
    // 如果没有找到，就继续从其原型上找，Object.getPrototypeOf方法用来获取指定对象的原型
    proto = Object.getPrototypeOf(proto);
  }
}
```

## 对 this 对象的理解

this 是执行上下文中的一个属性，它指向最后一次调用这个方法的对象。在实际开发中，this 的指向可以通过四种调用模式来判断。

- 第一种是函数调用模式，当一个函数不是一个对象的属性时，直接作为函数来调用时，this 指向全局对象。
- 第二种是方法调用模式，如果一个函数作为一个对象的方法来调用时，this 指向这个对象。
- 第三种是构造器调用模式，如果一个函数用 new 调用时，函数执行前会新创建一个对象，this 指向这个新创建的对象。
- 第四种是 apply 、 call 和 bind 调用模式，这三个方法都可以显示的指定调用函数的 this 指向。其中 apply 方法接收两个参数：一个是 this 绑定的对象，一个是参数数组。call 方法接收的参数，第一个是 this 绑定的对象，后面的其余参数是传入函数执行的参数。也就是说，在使用 call() 方法时，传递给函数的参数必须逐个列举出来。bind 方法通过传入一个对象，返回一个 this 绑定了传入对象的新函数。这个函数的 this 指向除了使用 new 时会被改变，其他情况下都不会改变。

这四种方式，使用构造器调用模式的优先级最高，然后是 apply、call 和 bind 调用模式，然后是方法调用模式，然后是函数调用模式。

## call() 、apply()、bind() 的区别？

call() 和 apply()作用是一样的,区别在于传参方式不同

- apply 接受两个参数，第一个参数指定了函数体内 this 对象的指向，第二个参数为一个带下标的集合，这个集合可以为数组，也可以为类数组，apply 方法把这个集合中的元素作为参数传递给被调用的函数。

- call 传入的参数数量不固定，跟 apply 相同的是，第一个参数也是代表函数体内的 this 指向，从第二个参数开始往后，每个参数被依次传入函数。

- bind 传参和 call 一样,bind 的作用是只修改 this 指向，但不会立即执行；会返回一个修改了 this 指向后的函数。需要调用才会执行

## 对象继承的方式有哪些?

（1）第一种是以原型链的方式来实现继承，但是这种实现方式存在的缺点是，在包含有引用类型的数据时，会被所有的实例对象所共享，容易造成修改的混乱。还有就是在创建子类型的时候不能向超类型传递参数。

（2）第二种方式是使用借用构造函数的方式，这种方式是通过在子类型的函数中调用超类型的构造函数来实现的，这一种方法解决了不能向超类型传递参数的缺点，但是它存在的一个问题就是无法实现函数方法的复用，并且超类型原型定义的方法子类型也没有办法访问到。

（3）第三种方式是组合继承，组合继承是将原型链和借用构造函数组合起来使用的一种方式。通过借用构造函数的方式来实现类型的属性的继承，通过将子类型的原型设置为超类型的实例来实现方法的继承。这种方式解决了上面的两种模式单独使用时的问题，但是由于我们是以超类型的实例来作为子类型的原型，所以调用了两次超类的构造函数，造成了子类型的原型中多了很多不必要的属性。

（4）第四种方式是原型式继承，原型式继承的主要思路就是基于已有的对象来创建新的对象，实现的原理是，向函数中传入一个对象，然后返回一个以这个对象为原型的对象。这种继承的思路主要不是为了实现创造一种新的类型，只是对某个对象实现一种简单继承，ES5 中定义的 Object.create() 方法就是原型式继承的实现。缺点与原型链方式相同。

（5）第五种方式是寄生式继承，寄生式继承的思路是创建一个用于封装继承过程的函数，通过传入一个对象，然后复制一个对象的副本，然后对象进行扩展，最后返回这个对象。这个扩展的过程就可以理解是一种继承。这种继承的优点就是对一个简单对象实现继承，如果这个对象不是自定义类型时。缺点是没有办法实现函数的复用。

（6）第六种方式是寄生式组合继承，组合继承的缺点就是使用超类型的实例做为子类型的原型，导致添加了不必要的原型属性。寄生式组合继承的方式是使用超类型的原型的副本来作为子类型的原型，这样就避免了创建不必要的属性。

## 异步编程的实现方式？

- 回调函数 的方式，使用回调函数的方式有一个缺点是，多个回调函数嵌套的时候会造成回调函数地狱，上下两层的回调函数间的代码耦合度太高，不利于代码的可维护。
- Promise 的方式，使用 Promise 的方式可以将嵌套的回调函数作为链式调用。但是使用这种方法，有时会造成多个 then 的链式调用，可能会造成代码的语义不够明确。
- generator 的方式，它可以在函数的执行过程中，将函数的执行权转移出去，在函数外部还可以将执行权转移回来。当遇到异步函数执行的时候，将函数执行权转移出去，当异步函数执行完毕时再将执行权给转移回来。因此在 generator 内部对于异步操作的方式，可以以同步的顺序来书写。使用这种方式需要考虑的问题是何时将函数的控制权转移回来，因此需要有一个自动执行 generator 的机制，比如说 co 模块等方式来实现 generator 的自动执行。
- async 函数 的方式，async 函数是 generator 和 promise 实现的一个自动执行的语法糖，它内部自带执行器，当函数内部执行到一个 await 语句的时候，如果语句返回一个 promise 对象，那么函数将会等待 promise 对象的状态变为 resolve 后再继续向下执行。因此可以将异步逻辑，转化为同步的顺序来书写，并且这个函数可以自动执行。

## 说一下对 promise 的理解

Promise 对象是异步编程的一种解决方案，最早由社区提出。Promise 是一个构造函数，接收一个函数作为参数，返回一个 Promise 实例。一个 Promise 实例有三种状态，分别是 pending、resolved 和 rejected，分别代表了进行中、已成功和已失败。实例的状态只能由 pending 转变 resolved 或者 rejected 状态，并且状态一经改变就无法再被改变了。

状态的改变是通过 resolve() 和 reject() 函数来实现的，可以在异步操作结束后调用这两个函数改变 Promise 实例的状态，它的原型上定义了一个 then 方法，使用这个 then 方法可以为两个状态的改变注册回调函数。这个回调函数属于微任务，会在本轮事件循环的末尾执行。

## 说一下 js 的事件循环(Event Loop)、宏任务(microTask)、微任务(microTask)

js 的事件循环相对较为复杂,这里我尽量以通俗的语言概括它们

js 是异步单线程的语言,即遇到一些耗时的操作譬如 setTimeout,dom 操作等等,js 不会等待其操作完成,而是将他们放入相应的任务队列中,当主线程执行完毕后再去轮询任务队列依次执行。

异步的任务又被分为微任务和宏任务,比如`promise中的.then中的回调`,`MutationObserver`,`process.nextTick(Node.js 环境)`属于**微任务**,`script( 整体代码)`,`setTimeout`,`setInterval`,`setImmediate(Node.js 环境)`等属于宏任务

我们可以把`<script>`中的代码当成一个宏任务,它会先执行,执行过程中会遇到微任务(如 promise)或者宏任务(如 setTimeout),他们会被放入相应的队列中。当执行完毕`<script>`的代码后,会去按顺序执行它所产生的微任务,当微任务执行完毕后会触发 dom 渲染(如果在浏览器中的话),此时一轮循环结束。然后会去按顺序执行宏任务队列中的宏任务,执行完一个宏任务的后,会执行这个宏任务所产生的微任务,然后再进行 dom 渲染(如果有 dom 操作的话),此时第二轮循环结束。然后去执行下一个宏任务....以此类推,这就是 js 的事件循环机制以及宏任务及微任务
