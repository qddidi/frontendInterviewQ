## map 和 Object 的区别

JavaScript 中的 Map 和对象（Object）是两种不同的数据结构，它们有一些区别和适用场景。

- 键的类型：对象的键只能是字符串或者 Symbol 类型，而 Map 的键可以是任意类型，包括对象、函数、NaN 等。

- 键值对的顺序：对象的键值对是无序的，而 Map 的键值对是有序的，即按照插入的顺序进行迭代。

- 键值对的个数：对象的键值对个数无法直接获取，需要通过遍历对象的属性来计算个数，而 Map 的键值对个数可以通过 size 属性直接获取。

- 迭代和遍历：对象的属性无法直接迭代，需要通过 Object.keys()、Object.values()或者 Object.entries()等方法来遍历对象的属性，而 Map 可以直接使用 for...of 循环或者 forEach()方法来迭代键值对。

- 内存占用：对象的属性和方法是存在原型链中的，每个对象都会继承一些公共的属性和方法，而 Map 只存储显式添加的键值对，不会继承任何属性和方法，因此在存储大量数据时，Map 相对于对象可以节省内存空间。

根据不同的需求，选择使用 Map 还是对象可以提高代码的可读性和性能。如果需要有序的键值对、键的类型不限、需要直接迭代键值对等场景，可以选择使用 Map。如果只需要简单的键值对存储和访问，并且键的类型为字符串或者 Symbol，可以选择使用对象

## map 和 weakMap 的区别

map 和 weakMap 都是一种键值对的集合,不同的是 weakMap 的键只能是对象且是弱引用的,所以如果键对象没有其他引用，它们可能会被垃圾回收器回收。由于 weakMap 的键是弱引用的,不知道键值什么时候会被回收,所以 weakMap 没有提供像 map 中的迭代方法和 size 属性等功能。

换言之，WeakMap 所构建的实例中，其 key 键所对应引用地址的引用断开或不属于指向同一个内存地址的时候，其对应 value 值就会被加入垃圾回收队伍。

## JavaScript 有哪些内置对象

JavaScript 中有许多内置对象，用于提供常用的功能和数据结构。以下是一些常见的内置对象：

- Object：JavaScript 中的所有对象都继承自 Object 对象。Object 对象提供了一些通用的方法，如创建对象、获取对象的属性和方法等。

- Array：Array 对象用于表示和操作数组。它提供了一系列的方法，如添加和删除元素、遍历数组、排序等。

- String：String 对象用于表示和操作字符串。它提供了一系列的方法，如获取字符串的长度、截取子串、查找和替换字符串等。

- Number：Number 对象用于表示和操作数字。它提供了一些常用的方法，如转换为字符串、四舍五入、取整等。

- Boolean：Boolean 对象用于表示和操作布尔值。它提供了一些方法，如转换为字符串、逻辑运算等。

- Date：Date 对象用于表示和操作日期和时间。它提供了一系列的方法，如获取当前日期和时间、格式化日期和时间等。

- Math：Math 对象提供了一些常用的数学方法和常量，如求平方根、取绝对值、生成随机数等。

- RegExp：RegExp 对象用于表示和操作正则表达式。它提供了一些方法，如匹配字符串、替换字符串等。

除了以上列举的内置对象，JavaScript 还提供了许多其他的内置对象，如 Function、Error、JSON 等，用于提供更多的功能和数据结构。这些内置对象可以直接在 JavaScript 中使用，无需额外的导入或安装。-

## JavaScript 脚本延迟加载的方式有哪些？

- 使用 async 属性：在`<script>`标签中添加 async 属性，这样脚本将会异步加载，不会阻塞页面的渲染。脚本加载完成后会立即执行。

- 使用 defer 属性：在`<script>`标签中添加 defer 属性，这样脚本将会异步加载，不会阻塞页面的渲染。脚本加载完成后会按照它们在页面中出现的顺序执行。

- 动态创建`<script>`标签：使用 JavaScript 动态创建`<script>`标签，并将其添加到页面中。这样可以控制脚本的加载时机，例如在页面加载完成后再加载脚本。

- 使用 Intersection Observer：使用 Intersection Observer API 来观察元素是否进入视口，当元素进入视口时再动态加载脚本。

这些方式可以根据具体的需求选择适合的方法来延迟加载 JavaScript 脚本，以提高页面的加载性能和用户体验。

## 什么是闭包?

闭包其实是指内部函数可以访问外部函数的变量,即使外部函数已经执行完毕,比如下面例子

```js
const fun = () => {
  let a = 1;
  const funIn = () => {
    console.log(a);
  };
  return funIn;
};
let funExec = fun();

funExec(); //1
```

在 `funIn` 函数中可以访问 `fun` 函数中的 `a`,当定义 `funExec` 的时候,`fun` 函数执行完毕。然后当我们调用 `funExec` 函数时依然可以访问到 `a` 变量。因为 `a` 变量处于一个闭包环境中,并不会被垃圾回收,所以闭包还可能导致**内存泄漏**

## js 的垃圾回收机制

JavaScript 中的垃圾回收机制是自动进行的，它负责释放不再被引用的对象所占用的内存空间。垃圾回收机制主要有以下几种算法和策略：

- 引用计数：引用计数是一种简单的垃圾回收算法，它通过记录每个对象被引用的次数来判断对象是否可达。当一个对象的引用计数为 0 时，说明该对象不再被引用，可以被垃圾回收器回收。然而，引用计数算法无法解决循环引用的问题，即两个或多个对象相互引用，但没有被其他对象引用的情况。

- 标记-清除：标记-清除是一种常用的垃圾回收算法。它通过标记所有的可达对象，然后清除所有未被标记的对象。垃圾回收器会从根对象（如全局对象、活动函数的局部变量等）开始，递归地遍历对象的引用关系，将可达对象进行标记，然后清除未被标记的对象。标记-清除算法可以解决循环引用的问题。

- 分代回收：分代回收是一种基于对象生命周期的垃圾回收策略。根据对象的存活时间将内存分为不同的代，一般分为新生代和老生代。新创建的对象会被分配到新生代，而经过多次垃圾回收仍然存活的对象会被提升到老生代。分代回收策略可以根据对象的存活时间来优化垃圾回收的效率。

- 增量回收：增量回收是一种优化垃圾回收的策略。它将垃圾回收的过程分为多个阶段，每个阶段执行一部分垃圾回收的工作，然后让 JavaScript 执行一段代码，再继续下一个阶段的垃圾回收工作。增量回收可以减少垃圾回收对 JavaScript 执行的影响，提高程序的响应性。

## 对 async/await 的理解

在 JavaScript 中，async/await 是一种用于处理异步操作的语法糖。它基于 Promise 对象，并提供了一种更简洁、更直观的方式来编写异步代码。

使用 async 关键字声明的函数被称为异步函数，它可以在函数体内使用 await 关键字来暂停函数的执行，等待一个 Promise 对象的解析结果。在等待期间，函数会暂停执行，并将控制权交给调用者，这样可以避免回调地狱和复杂的异步代码结构。

当 await 关键字后面的 Promise 对象被解析时，异步函数会恢复执行，并返回解析结果。如果 Promise 对象被拒绝，则会抛出一个错误，可以使用 try/catch 语句来捕获和处理这个错误。

async/await 的优点是可以使异步代码看起来更像是同步代码，更易于理解和维护。它也可以与其他异步操作结合使用，例如 Promise、fetch API 等。

需要注意的是，async/await 只是一种语法糖，底层仍然是基于 Promise 实现的。因此，它仍然需要处理 Promise 的状态和错误，以及遵循异步编程的原则。
