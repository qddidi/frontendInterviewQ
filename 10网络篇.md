## http 与 https 区别

HTTP（Hypertext Transfer Protocol）和 HTTPS（Hypertext Transfer Protocol Secure）是用于在客户端和服务器之间传输数据的两种协议。它们之间的主要区别在于安全性和数据传输方式。

- 安全性： HTTP 是明文传输的协议，数据在传输过程中不进行加密，容易被中间人窃听和篡改。而 HTTPS 使用 SSL/TLS 协议进行加密，能够确保传输的数据在网络上的安全性，使得中间人无法窃听、篡改或伪造网站。

- 默认端口： HTTP 使用 80 端口进行通信，而 HTTPS 使用 443 端口进行通信。

- 加密方式： HTTP 不涉及数据加密，而 HTTPS 使用 SSL/TLS 协议对数据进行加密。SSL/TLS 协议使用公钥加密来保护数据的机密性，并使用数字证书来验证服务器的身份。

- 证书： HTTPS 使用数字证书来验证服务器的身份，并确保连接的安全性。证书由可信的第三方机构（如 CA）签发，用于证明服务器是可信的。HTTP 没有使用证书进行身份验证。

- 连接建立过程： 在 HTTP 中，客户端与服务器之间建立连接后，数据的传输是不加密的。而在 HTTPS 中，客户端与服务器之间建立安全的 SSL/TLS 握手连接，然后使用加密通道进行数据传输。

- 性能： 由于 HTTPS 需要进行加密和解密的过程，相比 HTTP 而言，HTTPS 会对服务器的性能产生一定的影响。但是随着硬件性能的提升和优化的算法实现，这种性能影响已经大大减少。

## get 和 post 区别

- 请求类型： GET 是一种用于从服务器获取数据的请求方法，而 POST 是一种用于向服务器提交数据的请求方法。

- 数据传输方式： 在 GET 请求中，数据以查询字符串的形式附加在 URL 的末尾，通过 URL 进行传输。在 POST 请求中，数据通过请求体的形式传输，不会显示在 URL 中，相对于 GET 请求更加安全。

- 数据长度限制： GET 请求对 URL 的长度有限制，不同的浏览器和服务器可能会有不同的限制，通常在几千个字符左右。而 POST 请求没有这个限制，可以传输大量的数据。

- 安全性： GET 请求的数据在 URL 中明文传输，因此不适合传输敏感信息，可能被浏览器缓存、历史记录、服务器日志等记录下来。而 POST 请求的数据是通过请求体传输的，相对来说更安全，不容易被拦截。

- 请求语义： GET 请求应该是幂等的，即对同一个 URL 的多次 GET 请求不会对服务器产生副作用。而 POST 请求可能对服务器产生副作用，比如创建、更新或删除资源，不是幂等的。

- 浏览器行为： 在浏览器中，当使用 GET 请求时，浏览器会将请求结果缓存起来，以便下次请求相同的 URL 时可以从缓存中取回结果，提高性能。而 POST 请求不会被缓存，每次请求都会从服务器获取最新的结果。

## 常见的 HTTP 请求头和响应头

**请求头:**

- Host：指定请求的目标主机和端口号。
- User-Agent：标识客户端（通常是浏览器）的信息，用于服务器识别客户端的类型和版本。
- Accept：指定客户端能够处理的 MIME 类型（媒体类型）。
- Content-Type：指定请求体中数据的 MIME 类型，用于告诉服务器如何解析请求体中的数据。
- Authorization：提供身份验证凭证，用于访问需要认证的资源。
- Cookie：存储在客户端的小型文本文件，用于存储会话信息或跟踪用户状态。
- Referer：指示客户端是通过哪个页面或 URL 发送的当前请求。
- Cache-Control：指示客户端或服务器如何缓存请求或响应的内容。

**响应头**

- Content-Type：指定响应体中数据的 MIME 类型，用于告诉客户端如何解析响应体中的数据。
- Content-Length：指定响应体的长度（字节数）。
- Server：标识服务器的软件及版本信息。
- Set-Cookie：用于在客户端存储 cookie。
- Location：用于重定向响应，通知客户端应该访问的新 URL。
- Cache-Control：指示客户端或服务器如何缓存请求或响应的内容。
- Expires：指定响应过期的日期时间，用于客户端缓存控制。
- Access-Control-Allow-Origin：指示服务器是否允许跨域请求。

## 常见的 HTTP 请求方法

- GET：用于从服务器获取资源，一般用于读取数据。对同一个 URL 的多次 GET 请求应该是幂等的，即对服务器没有副作用。

- POST：用于向服务器提交数据，一般用于创建新资源或执行某种操作。POST 请求可能对服务器产生副作用，不是幂等的。

- PUT：用于向服务器更新整个资源。请求将替换掉目标 URL 上的所有现有表示，如果资源不存在，也可以用 PUT 来创建新资源。

- PATCH：用于向服务器部分更新资源，仅传输需要更改的部分。PATCH 请求是幂等的，因为多次相同的 PATCH 请求不应造成不同的结果。

- DELETE：用于删除服务器上的资源。

- HEAD：类似于 GET 请求，但只返回响应头信息，不返回响应体。HEAD 请求常用于获取资源的元数据，如检查资源是否存在、最后修改时间等。

- OPTIONS：用于获取服务器支持的请求方法、资源所支持的 HTTP 选项等信息。

## HTTP 1.0 、 HTTP 1.1 和 HTTP2.0 区别

1. 连接复用（Connection Multiplexing）：

HTTP 1.0：每次客户端请求都需要建立新的 TCP 连接。在连接建立后，客户端请求一次，服务器响应一次，然后关闭连接。

HTTP 1.1：支持持久连接，也称为 HTTP Keep-Alive。在一个 TCP 连接上，客户端可以发送多个请求，服务器可以返回多个响应，不会立即关闭连接。这减少了连接建立和关闭的开销。

HTTP/2：引入了多路复用，即在同一个 TCP 连接上可以并发发送多个请求和接收多个响应。这消除了串行化请求的限制，提高了性能和效率。

2. 请求和响应头压缩（Header Compression）：

HTTP 1.0 和 1.1：使用明文传输的请求头和响应头，相对较大，占用带宽。

HTTP/2：使用 HPACK 压缩算法对请求头和响应头进行压缩，减少了传输的大小，降低了带宽消耗。

3. 二进制协议（Binary Protocol）：

HTTP 1.0 和 1.1：使用文本格式进行通信，每个数据字段都以文本形式传输。

HTTP/2：采用二进制分帧层传输数据，提高了解析效率和传输速度。

4. 流控制（Stream Control）：

HTTP 1.0 和 1.1：不支持流控制，数据只能串行传输。

HTTP/2：支持流控制，通过设置优先级、流量控制窗口等方式，可以有效控制数据的传输和优先级。

5. 服务器推送（Server Push）：

HTTP 1.0 和 1.1：客户端需要发送请求来获取资源。

HTTP/2：服务器可以在客户端未请求的情况下主动推送资源给客户端，以提前缓存资源，减少延迟。

## 当在浏览器中输入网址并且按下回车之后发生了什么？

URL 解析： 浏览器会解析输入的 URL，并提取出其中的协议（如 HTTP 或 HTTPS）、域名和路径等相关信息。

DNS 解析： 浏览器将解析出的域名发送到本地 DNS 解析器或者系统预配置的 DNS 服务器，以获取目标服务器的 IP 地址。

建立 TCP 连接： 浏览器会通过 IP 地址建立与目标服务器的 TCP 连接。这个过程涉及三次握手，即客户端与服务器之间的连接协商。

发送 HTTP 请求： 在建立 TCP 连接完成后，浏览器会发送一个 HTTP 请求到目标服务器，其中包括请求方法（如 GET、POST）、路径和 HTTP 版本等。

服务器处理请求： 目标服务器接收到请求后，会进行相应的处理，可能涉及动态生成页面、查询数据库等操作。

服务器发送 HTTP 响应： 服务器根据请求进行处理后，会生成一个 HTTP 响应，其中包括状态码、响应头和响应体等。

接收响应： 浏览器接收到来自服务器的 HTTP 响应。

渲染页面： 浏览器根据接收到的响应，开始解析 HTML、CSS 和 JavaScript 等文件。它会构建 DOM 树、CSSOM 树并执行 JavaScript 代码，最终将页面渲染在用户的屏幕上。

关闭连接： 页面渲染完成后，浏览器会关闭与服务器的 TCP 连接，释放资源。

## 对 keep-alive 的理解

- 连接复用：在传统的非持久连接中，每个 HTTP 请求都需要建立一个新的 TCP 连接。而在 Keep-Alive 下，客户端和服务器之间可以复用同一个 TCP 连接来发送多个请求和响应，从而减少了连接建立和关闭的开销。

- 减少延迟：由于在 Keep-Alive 连接中，TCP 连接一直保持打开状态，客户端无需每次请求都经历 TCP 的三次握手和四次挥手，从而减少了延迟。

- 资源优化：Keep-Alive 技术可以减少服务器的资源占用，因为它避免了频繁的 TCP 连接的建立和关闭过程，减少了服务器的压力。

- 并行请求：由于 TCP 连接在 Keep-Alive 下保持打开状态，客户端可以同时发送多个 HTTP 请求，提高了并行处理能力，从而加快了页面加载速度。

- 超时机制：在 Keep-Alive 连接中，当一定时间内没有新的请求到达时，连接可能会被关闭，以释放服务器资源。这个超时机制可以在 HTTP 头部的 Keep-Alive 字段中进行配置。

需要注意的是，Keep-Alive 并不是无限期保持连接的，它仅在一定时间内保持连接打开。并且，不是所有的 HTTP 请求都适合使用 Keep-Alive。例如，对于大文件下载或长时间不活跃的连接，关闭 Keep-Alive 可能会更合适。

## 页面有多张图片，HTTP 是怎样的加载表现？

- 在 HTTP 1 下，浏览器对一个域名下最大 TCP 连接数为 6，所以会请求多次。可以用多域名部署解决。这样可以提高同时请求的数目，加快页面图片的获取速度。
- 在 HTTP 2 下，可以一瞬间加载出来很多资源，因为，HTTP2 支持多路复用，可以在一个 TCP 连接中发送多个 HTTP 请求

## HTTP 请求报文的是什么样的？

请求报⽂有 4 部分组成:

- 请求⾏
- 请求头部
- 空⾏
- 请求体

![1](https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/4fb5bb2cb1664850b52e32d57af74f2f~tplv-k3u1fbpfcp-zoom-in-crop-mark:1512:0:0:0.awebp)

其中：

（1）请求⾏包括：请求⽅法字段、URL 字段、HTTP 协议版本字段。它们⽤空格分隔。例如，GET /index.html HTTP/1.1。

（2）请求头部:请求头部由关键字/值对组成，每⾏⼀对，关键字和值⽤英⽂冒号“:”分隔

User-Agent：产⽣请求的浏览器类型。

Accept：客户端可识别的内容类型列表。

Host：请求的主机名，允许多个域名同处⼀个 IP 地址，即虚拟主机。

（3）请求体: post put 等请求携带的数据

![2](https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/eacc55d7152149e99730346f1edfc9ab~tplv-k3u1fbpfcp-zoom-in-crop-mark:1512:0:0:0.awebp)

## HTTP 响应报文的是什么样的？

请求报⽂有 4 部分组成:

- 响应⾏ 由网络协议版本，状态码和状态码的原因短语组成，例如 HTTP/1.1 200 OK
- 响应头 响应部⾸组成
- 空⾏
- 响应体 服务器响应的数据

![3](https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/1b0183eb91ce451aa17bd515d047062d~tplv-k3u1fbpfcp-zoom-in-crop-mark:1512:0:0:0.awebp)

## HTTP 协议的优点和缺点

优点：

简单和易于理解：HTTP 协议使用简单的文本格式，在设计上非常直观和易于理解。这简化了开发人员编写 HTTP 请求和处理 HTTP 响应的过程。

平台无关性：HTTP 协议是独立于操作系统和编程语言的，可以在不同平台之间进行通信。这使得 HTTP 成为互联网上广泛应用的通信协议。

跨平台和跨语言支持：HTTP 协议可以被几乎所有的编程语言和应用程序库支持，因此可以轻松地实现跨平台的数据交换和通信。

可扩展性：HTTP 协议使用灵活的请求-响应模式，可以通过添加、修改和删除标头字段等方式进行功能的扩展和定制。

安全性：HTTP 协议支持通过 TLS/SSL 协议进行数据的加密传输，以确保敏感信息在网络传输过程中的安全性。

缺点：

无状态性：HTTP 协议是无状态的，每个请求和响应之间是相互独立的，服务器无法直接识别某个请求和之前的请求之间的关系。这导致无法在单个连接上保持会话状态，需要使用会话管理机制（如 Cookies）来解决。

性能较低：由于 HTTP 协议在每个请求和响应都需要建立和关闭连接，若频繁地进行请求和响应，会导致较高的延迟和性能问题。这对于一些需要实时性和低延迟的应用来说可能是一个缺点。

明文传输：HTTP 协议默认以明文方式传输数据，这意味着数据在网络上可能会被窃听和篡改。虽然可以通过 TLS/SSL 对 HTTP 进行加密，但是这需要额外的计算和网络资源。

可伪造性：由于 HTTP 的请求和响应是以明文方式进行传输的，攻击者可以轻易地伪造或篡改请求和响应，从而可能引发安全风险。

> 尽管 HTTP 协议有一些缺点，但它仍然是应用程序之间进行通信的重要协议，特别是在 Web 开发中。为了解决一些 HTTP 协议的缺点，有时候会使用其他协议（如 WebSocket）或结合其他技术和机制（如 HTTP/2、HTTPS）来提高性能、安全性和开发效率。

## 说一下 HTTP 3.0
